FreeRTOS
*************

序言
=============
我觉得对 FreeRTOS 的理解首先需要对 FreeRTOS 的背景了解开始切入比较合适。

.. important::
   首先我们需要知道 FreeRTOS 的出现是为了解决什么问题。

* 相对于传统的 MCU 开发，大家最熟悉的应该是“前台操作系统”，一个 “大循环” 处理我们的所有任务，然后有时候还会处理下中断响应。对于这种情况我们的开发通常不会涉及到什么复杂的情况，功能相对单一，所以在没有操作系统的帮助下我们也能完成开发需求，即使任务多了点，我们也可以靠自己的实现的状态机了搞定问题。
* 对于单一问题我可以考虑用 “前台系统” 对于多任务我可以考虑状态机，那么请问对于对任务又要保证相应任务的事实性你怎么办？你的状态机可搞不定了吧，你也不知道 CPU 何时才能才能处理到指定的任务，如果 CPU 当时正在处理你的其他任务，那肯定得等到其他任务处理完，等状态机判断成功进入到你指定的任务时才能达到目的。对于这种情况我们就可以理解成 “没有实时性”
* 那么实时操作系统就是帮助我们控制任务实时性的。


对于实时操作系统影响核心的两个关键就是 “中断” 和 “时间片”。我先说一下 “中断”，这里我先不说硬件的内部中断，现在想说的是由用户产生的外部硬件中断，比如用户按下一个按钮，现在想马上响应按钮事件怎么办？

用中断，要不你就放在你的 ISR [#f1]_ 这样就能在第一时间响应我们的服务。 但是请知晓没有严格意义上的实时，硬件响应是需要时间的，CPU 处理程序也是需要时间的。只不过他们需要的时间很少很少，少到我们可以忽略，所以我们称之为实时系统。实时系统按书面的说法分为软实时和硬实时，硬实时就是在规定时间单位内系统必须响应我们的程序，软实时就是响应时间可以滞后，但不会太久。说回主线，要不你就在 ISR 里唤醒你的任务，等 OS 调度到你的任务后才执行服务。利用中断来帮助我们控制任务的实时性就在这里。还有一个就是 “时间片”，在实时操作系统中我们常用的调度算法应该是 “抢占式分时算法”，对于同一优先级的任务，我们希望它们能公平的占用 CPU，而每一个任务能占据 CPU 的时间被切割成一个个时间片，每个任务能运行的时间片到了就可能被重新调度，如果同优先级下还有其他任务，那么它就会被切换出去让新的任务进来。这个时间片就能影响任务切换精度的关键。

那么 FreeRTOS 就是为了让我们这些菜鸟自己不会写实时操作系统，而又能够用上时实操作系统而诞生的。FreeRTOS 到底算不算能不能达到实时操作系统的标准呢？我不知道，但是对于普通开发者来说，对于任务的实时性我们应该也不是太追求，毕竟不是每个人都是在造火箭的，更多的人还是在让 MCU 打印自己那两句 "Hello World" 就够了，我感觉对于更多开发者对实时 OS 的使用应该是它的分时调度而已，就是像 PC 操作系统那么，实现所谓的并发。一般我们的 MCU 就只有一个核，一个核在同一时间只能处理一个任务，多个任务不能实现并行，只能做到并发。并行就是多个核同时在处理任务，并发就是一个核在疯狂的来回切换任务，只对任务进行短暂的响应，并发你可以想象成一个 “时间管理者大师” 在多个女朋友之间迂回，而每个女朋友看似和一个正常的一心一意的男朋友在交往，但其实她并不是在独享。这就是 “时间管理者” 的精妙之处。

“时间管理者” 的行为不可取，但是他对时间的掌控我们还是可以学习的，那么下面我们就开始 FreeRTOS 的学习吧。

==================  ====================  ========================
|任务控制|_          |内存管理|_             |任务同步|_
------------------  --------------------  ------------------------
`任务控制`_          `内存管理`_             `任务同步`_
------------------  --------------------  ------------------------
|定时器|_                        
------------------  --------------------  ------------------------
`定时器`_                      
==================  ====================  ========================

.. |任务控制| image:: _static/task.png
.. _任务控制: task/index.html

.. |内存管理| image:: _static/memory.png
.. _内存管理: memory/index.html

.. |任务同步| image:: _static/synchronization.png
.. _任务同步: Synchronization/index.html

.. |定时器| image:: _static/timer.png
.. _定时器: Timer/index.html

.. [#f1] ISR: `Interrupt Service Routines <https://en.wikipedia.org/wiki/Interrupt_handler>`__.

正文
==============

.. toctree::
   :maxdepth: 1
   
   task
   memory
   synchronization
   timer